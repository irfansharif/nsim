extern crate rand;

use std::collections::VecDeque;
use generators::Generator;
use self::rand::{thread_rng, Rng};

// Packet holds the value of the time unit that it was generated at, and its length.
#[derive(Clone)]
pub struct Packet {
    pub time_generated: u32,
    pub destination_id: u32,
    pub length: u32,
}

// NodeStatistics is the set of statistics we care about post-simulation as far as the node is
// concerned.
pub struct NodeStatistics {
    pub packets_generated: u32,
}

impl NodeStatistics {
    fn new() -> NodeStatistics {
        NodeStatistics { packets_generated: 0 }
    }
}

// Node generates packets according as per the parametrized generators::Generator. We maintain a
// ticker count to the next time a packet is to be generated, moving forward at ticks of the
// specified resolution. We also collect node statistics through this progression.
pub struct Node<G: Generator> {
    resolution: f64,
    ticker: u32,
    peers: Vec<u32>,
    generator: G,
    statistics: NodeStatistics,
}

impl<G: Generator> Node<G> {
    // Node::new seeds the ticker using the provided generator.
    pub fn new(generator: G, resolution: f64, peers: Vec<u32>) -> Node<G> {
        assert!(peers.len() != 0);
        Node {
            resolution: resolution,
            ticker: generator.next_event(resolution),
            peers: peers,
            generator: generator,
            statistics: NodeStatistics::new(),
        }
    }

    // The caller is responsible for calling Node.tick() at fixed time intervals, moving the
    // node simulator one time unit per call. We return a boolean indicating whether or not a
    // packet is generated in the most recently completed time unit.
    //
    // We're careful to check if self.ticker == 0 before decrementing because the parametrized
    // generator may very well return 0 (see top-level comment in src/generators.rs).
    pub fn tick(&mut self) -> Option<u32> {
        // TODO(irfansharif): Resolution mismatch; no possibility of generating multiple packets.
        if self.ticker == 0 {
            self.statistics.packets_generated += 1;
            self.ticker = self.generator.next_event(self.resolution);
            return Some(thread_rng().choose(&self.peers).unwrap().to_owned());
        }

        self.ticker -= 1;
        if self.ticker == 0 {
            self.statistics.packets_generated += 1;
            self.ticker = self.generator.next_event(self.resolution);
            Some(thread_rng().choose(&self.peers).unwrap().to_owned())
        } else {
            None
        }
    }

    // Node.packets_generated returns the number of packets generated by the node thus far.
    pub fn packets_generated(&self) -> u32 {
        self.statistics.packets_generated
    }
}

// HubStatistics is the set of statistics we care about post-simulation as far as the hub is
// concerned.
pub struct HubStatistics {
    pub packets_processed: u32,
    pub packets_dropped: u32,
    pub idle_count: u32,
    pub process_count: u32,
}

impl HubStatistics {
    fn new() -> HubStatistics {
        HubStatistics {
            packets_processed: 0,
            packets_dropped: 0,
            idle_count: 0,
            process_count: 0,
        }
    }
}

// Hub stores packets in a queue and processes them.
pub struct Hub {
    queue: VecDeque<Packet>,
    buffer_limit: Option<usize>,
    resolution: f64,
    pub statistics: HubStatistics,
    // Processing variables
    pspeed: f64,
    currently_processing: Option<Packet>,
    bits_processed: f64,
}

impl Hub {
    // Hub::new returns a hub with the specified buffer limit, if any.
    pub fn new(resolution: f64, pspeed: f64, buffer_limit: Option<usize>) -> Hub {
        Hub {
            queue: VecDeque::new(),
            buffer_limit: buffer_limit,
            resolution: resolution,
            statistics: HubStatistics::new(),
            pspeed: pspeed,
            currently_processing: None,
            bits_processed: 0.0,
        }
    }

    // Hub.enqueue enqueues a packet for delivery. If the packet is to be dropped (due to the
    // internal queue being full it is recorded in the hub's internal statistics.
    pub fn enqueue(&mut self, packet: Packet) {
        match self.buffer_limit {
            Some(limit) => {
                if self.queue.len() < limit {
                    self.queue.push_back(packet);
                } else {
                    self.statistics.packets_dropped += 1
                }
            }
            // Infinite queue, limit == None.
            None => {
                self.queue.push_back(packet);
            }
        }
    }

    // Hub.tick checks to see if a packet is currently being processed, and if so,
    // increments Hub.bits_processed, and if the resulting sum is equal to the bits
    // in the packet, then it returns the packet and resets the state of Hub.
    pub fn tick(&mut self) -> Option<Packet> {
        match self.currently_processing.clone() {
            Some(p) => {
                self.bits_processed += self.pspeed / self.resolution;
                if (self.bits_processed as u32) < p.length {
                    self.statistics.process_count += 1;
                    return None;
                }
                self.currently_processing = None;
                self.bits_processed = 0.0;
                self.statistics.packets_processed += 1;
                self.statistics.process_count += 1;
                Some(p)
            }
            None => {
                match self.queue.pop_front() {
                    Some(p) => {
                        self.currently_processing = Some(p.clone());
                        self.bits_processed += self.pspeed / self.resolution;
                        if (self.bits_processed as u32) < p.length {
                            return None;
                        }
                        self.currently_processing = None;
                        self.bits_processed = 0.0;
                        self.statistics.packets_processed += 1;
                        self.statistics.process_count += 1;
                        Some(p)
                    }
                    None => {
                        self.statistics.idle_count += 1;
                        None
                    }
                }
            }
        }
    }

    // Hub.qlen returns the number of packets in the hub's internal buffer, waiting to be
    // processed.
    pub fn qlen(&self) -> usize {
        self.queue.len()
    }

    // Hub.packets_processed returns the number of packets processed by the hub thus far.
    pub fn packets_processed(&self) -> u32 {
        self.statistics.packets_processed

    }

    // Hub.packets_dropped returns the number of packets dropped by the hub thus far.
    pub fn packets_dropped(&self) -> u32 {
        self.statistics.packets_dropped
    }

    // Hub.idle_proportion returns the proportion of time the hub is left idle thus far.
    pub fn idle_proportion(&self) -> f64 {
        f64::from(self.statistics.idle_count) /
            f64::from(self.statistics.idle_count + self.statistics.process_count) * 100.0
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use super::super::generators::Deterministic;

    #[test]
    fn node_packet_generation() {
        let mut c = Node::new(Deterministic::new(0.5), 1.0);
        assert!(!c.tick());
        assert!(c.tick());
    }

    #[test]
    fn hub_packet_delivery() {
        let mut s = Hub::new(1.0, 0.5, None);
        s.enqueue(Packet {
            time_generated: 0,
            length: 1,
        });
        s.enqueue(Packet {
            time_generated: 0,
            length: 1,
        });
        s.tick();
        assert_eq!(s.statistics.packets_processed, 0);

        s.tick();
        assert_eq!(s.statistics.packets_processed, 1);

        s.tick();
        assert_eq!(s.statistics.packets_processed, 1);

        s.tick();
        assert_eq!(s.statistics.packets_processed, 2);
    }

    #[test]
    fn hub_packet_dropped() {
        let mut s = Hub::new(1.0, 1.0, Some(1));
        s.enqueue(Packet {
            time_generated: 0,
            length: 1,
        });
        s.enqueue(Packet {
            time_generated: 0,
            length: 1,
        });

        s.tick();
        assert_eq!(s.statistics.packets_processed, 1);
        assert_eq!(s.statistics.packets_dropped, 1);
    }

    #[test]
    fn hub_idle_count() {
        let mut s = Hub::new(1.0, 1.0, Some(1));

        s.tick();
        assert_eq!(s.statistics.idle_count, 1);

        s.tick();
        assert_eq!(s.statistics.idle_count, 2);

        s.enqueue(Packet {
            time_generated: 0,
            length: 1,
        });
        s.tick();
        assert_eq!(s.statistics.idle_count, 2);
        assert_eq!(s.statistics.packets_processed, 1);
    }
}
